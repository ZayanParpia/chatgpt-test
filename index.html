package com.example.obstrue

import android.app.usage.UsageEvents
import android.app.usage.UsageStatsManager
import android.content.Intent
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import com.example.obstrue.ui.statistics.ObstrueStatistics
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

import android.provider.Settings
import android.view.ViewGroup
import android.view.WindowManager
import android.widget.FrameLayout
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.ImageBitmap
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.graphics.drawable.toBitmap
import androidx.compose.foundation.layout.navigationBarsPadding
import androidx.compose.ui.viewinterop.AndroidView
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navOptions
import com.example.obstrue.ui.theme.ObstrueTheme
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.Job
import kotlinx.coroutines.isActive
import org.json.JSONArray
import org.json.JSONObject
import android.content.Context
import java.util.Calendar

// ExoPlayer / Media3 imports are used later in the file for the splash video composable.
// (I'll include the detailed video composable in the second half.)
import androidx.compose.runtime.DisposableEffect
import androidx.compose.ui.platform.LocalContext
import androidx.annotation.RawRes
import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.PlayerView

// -------------------- Helper: readable minutes -> friendly string --------------------
private fun formatMinutesReadable(minutes: Int): String {
    if (minutes <= 0) return "—"
    if (minutes < 60) return "${minutes} min"
    val h = minutes / 60
    val m = minutes % 60
    return if (m == 0) {
        "${h} hr"
    } else {
        "${h} hr ${m} min"
    }
}

// -------------------- Persistence helpers (unchanged) --------------------
private fun saveInstalledAppsToPrefs(context: Context, apps: List<AppEntry>) {
    try {
        val prefs = context.getSharedPreferences("obstrue_prefs", Context.MODE_PRIVATE)
        val arr = JSONArray()
        for (app in apps) {
            val o = JSONObject()
            o.put("package", app.packageName)
            o.put("label", app.label)
            arr.put(o)
        }
        prefs.edit().putString("installed_apps", arr.toString()).apply()
    } catch (e: Exception) {
        // ignore
    }
}

private fun saveBlockedAppsToPrefs(context: Context, apps: List<AppEntry>) {
    try {
        val prefs = context.getSharedPreferences("obstrue_prefs", Context.MODE_PRIVATE)
        val arr = JSONArray()
        for (app in apps) {
            val o = JSONObject()
            o.put("package", app.packageName)
            o.put("label", app.label)
            arr.put(o)
        }
        prefs.edit().putString("blocked_apps", arr.toString()).apply()
    } catch (e: Exception) {
        // ignore
    }
}

private fun saveAppTimeLimitToPrefs(context: Context, pkg: String, minutes: Int) {
    try {
        val prefs = context.getSharedPreferences("obstrue_prefs", Context.MODE_PRIVATE)
        val existing = prefs.getString("app_time_limits", "{}") ?: "{}"
        val obj = JSONObject(existing)
        obj.put(pkg, minutes)
        prefs.edit().putString("app_time_limits", obj.toString()).apply()
    } catch (_: Exception) {
        // ignore
    }
}

private fun removeAppTimeLimitFromPrefs(context: Context, pkg: String) {
    try {
        val prefs = context.getSharedPreferences("obstrue_prefs", Context.MODE_PRIVATE)
        val existing = prefs.getString("app_time_limits", null) ?: return
        val obj = JSONObject(existing)
        if (obj.has(pkg)) {
            obj.remove(pkg)
            prefs.edit().putString("app_time_limits", obj.toString()).apply()
        }
    } catch (_: Exception) {
        // ignore
    }
}

private fun loadAppTimeLimitsFromPrefs(context: Context): Map<String, Int> {
    val out = mutableMapOf<String, Int>()
    try {
        val prefs = context.getSharedPreferences("obstrue_prefs", Context.MODE_PRIVATE)
        val saved = prefs.getString("app_time_limits", null) ?: return out
        val obj = JSONObject(saved)
        val keys = obj.keys()
        while (keys.hasNext()) {
            val k = keys.next()
            val v = obj.optInt(k, 0)
            out[k] = v
        }
    } catch (_: Exception) {
        // ignore
    }
    return out
}

private fun saveAppUsageToPrefs(context: Context, pkg: String, minutes: Int) {
    try {
        val prefs = context.getSharedPreferences("obstrue_prefs", Context.MODE_PRIVATE)
        val existing = prefs.getString("app_usage", "{}") ?: "{}"
        val obj = JSONObject(existing)
        obj.put(pkg, minutes)
        prefs.edit().putString("app_usage", obj.toString()).apply()
    } catch (_: Exception) {
        // ignore
    }
}

private fun removeAppUsageFromPrefs(context: Context, pkg: String) {
    try {
        val prefs = context.getSharedPreferences("obstrue_prefs", Context.MODE_PRIVATE)
        val existing = prefs.getString("app_usage", null) ?: return
        val obj = JSONObject(existing)
        if (obj.has(pkg)) {
            obj.remove(pkg)
            prefs.edit().putString("app_usage", obj.toString()).apply()
        }
    } catch (_: Exception) {
        // ignore
    }
}

private fun loadAppUsageFromPrefs(context: Context): Map<String, Int> {
    val out = mutableMapOf<String, Int>()
    try {
        val prefs = context.getSharedPreferences("obstrue_prefs", Context.MODE_PRIVATE)
        val saved = prefs.getString("app_usage", null) ?: return out
        val obj = JSONObject(saved)
        val keys = obj.keys()
        while (keys.hasNext()) {
            val k = keys.next()
            val v = obj.optInt(k, 0)
            out[k] = v
        }
    } catch (_: Exception) {
        // ignore
    }
    return out
}

private fun loadBlockedAppsFromPrefs(context: Context): List<AppEntry> {
    val out = mutableListOf<AppEntry>()
    try {
        val prefs = context.getSharedPreferences("obstrue_prefs", Context.MODE_PRIVATE)
        val saved = prefs.getString("blocked_apps", null) ?: return out
        val arr = JSONArray(saved)
        val pm = context.packageManager
        for (i in 0 until arr.length()) {
            val o = arr.optJSONObject(i) ?: continue
            val pkg = o.optString("package", "")
            val label = o.optString("label", pkg)
            val iconBitmap: ImageBitmap = try {
                val drawable = pm.getApplicationIcon(pkg)
                drawable.toBitmap().asImageBitmap()
            } catch (_: Exception) {
                try {
                    val drawable = context.resources.getDrawable(R.drawable.unlock, null)
                    drawable.toBitmap().asImageBitmap()
                } catch (_: Exception) {
                    android.graphics.Bitmap.createBitmap(1, 1, android.graphics.Bitmap.Config.ARGB_8888).asImageBitmap()
                }
            }

            out.add(
                AppEntry(
                    packageName = pkg,
                    label = label,
                    iconBitmap = iconBitmap,
                    installerPackage = null,
                    isSystemApp = false,
                    isUpdatedSystemApp = false
                )
            )
        }
    } catch (_: Exception) {
        // ignore parse errors
    }
    return out
}

private data class AppEntry(
    val packageName: String,
    val label: String,
    val iconBitmap: ImageBitmap,
    val installerPackage: String? = null,
    val isSystemApp: Boolean = false,
    val isUpdatedSystemApp: Boolean = false
)

// -------------------- Usage helper: compute precise foreground time --------------------
/**
 * Compute per-package foreground minutes for [packages] between today's midnight and now.
 * Primary method: UsageEvents (MOVE_TO_FOREGROUND / MOVE_TO_BACKGROUND) — most precise.
 * Fallbacks: queryAndAggregateUsageStats (API 29+), then queryUsageStats daily interval.
 *
 * Returns map package -> minutesUsed (rounded down).
 */
private suspend fun getUsageMinutesForPackages(context: Context, packages: List<String>): Map<String, Int> {
    // Guard
    if (packages.isEmpty()) return emptyMap()

    return try {
        // Run heavy work on IO dispatcher
        kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.IO) {
            val out = mutableMapOf<String, Int>()
            val usm = context.getSystemService(Context.USAGE_STATS_SERVICE) as? UsageStatsManager
            if (usm == null) {
                return@withContext out
            }

            // compute today's midnight -> now
            val cal = Calendar.getInstance()
            val end = System.currentTimeMillis()
            cal.set(Calendar.HOUR_OF_DAY, 0)
            cal.set(Calendar.MINUTE, 0)
            cal.set(Calendar.SECOND, 0)
            cal.set(Calendar.MILLISECOND, 0)
            val start = cal.timeInMillis

            // Attempt primary: UsageEvents
            try {
                val events = usm.queryEvents(start, end)
                val ev = UsageEvents.Event()
                val totals = mutableMapOf<String, Long>()    // totals per package in ms
                val lastForeground = mutableMapOf<String, Long>() // last foreground timestamp per pkg

                while (events.hasNextEvent()) {
                    events.getNextEvent(ev)
                    val pkg = ev.packageName ?: continue
                    when (ev.eventType) {
                        UsageEvents.Event.MOVE_TO_FOREGROUND -> {
                            lastForeground[pkg] = ev.timeStamp
                        }
                        UsageEvents.Event.MOVE_TO_BACKGROUND -> {
                            val startTs = lastForeground.remove(pkg)
                            if (startTs != null && ev.timeStamp >= startTs) {
                                val prev = totals[pkg] ?: 0L
                                totals[pkg] = prev + (ev.timeStamp - startTs)
                            }
                        }
                        else -> {
                            // ignore other events
                        }
                    }
                }

                // If any package still marked foreground at 'end', add (end - start)
                for ((pkg, startTs) in lastForeground) {
                    if (end >= startTs) {
                        val prev = totals[pkg] ?: 0L
                        totals[pkg] = prev + (end - startTs)
                    }
                }

                // fill out map for requested packages
                for (pkg in packages) {
                    val ms = totals[pkg] ?: 0L
                    val minutes = (ms / 60000L).toInt()
                    out[pkg] = minutes
                }

                // return results
                return@withContext out
            } catch (e: Exception) {
                // UsageEvents may be restricted on some devices — fall back
            }

            // Fallback 1: aggregated API (API 29+)
            try {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    val aggregated = usm.queryAndAggregateUsageStats(start, end)
                    for (pkg in packages) {
                        val minutes = (aggregated[pkg]?.totalTimeInForeground ?: 0L / 60000L).toInt()
                        out[pkg] = minutes
                    }
                    return@withContext out
                }
            } catch (e: Exception) {
                // ignore and try next fallback
            }

            // Fallback 2: queryUsageStats DAILY interval and sum
            try {
                val list = usm.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, start, end) ?: emptyList()
                val mapTotals = mutableMapOf<String, Long>()
                for (u in list) {
                    val pkg = u.packageName
                    val prev = mapTotals[pkg] ?: 0L
                    val add = try { u.totalTimeInForeground } catch (_: Exception) { 0L }
                    mapTotals[pkg] = prev + add
                }
                for (pkg in packages) {
                    val minutes = (mapTotals[pkg] ?: 0L / 60000L).toInt()
                    out[pkg] = minutes
                }
            } catch (e: Exception) {
                // ignore; will return zeros for missing
                for (pkg in packages) out[pkg] = 0
            }

            return@withContext out
        }
    } catch (t: Throwable) {
        // protect caller: return zero map on any unexpected error
        return emptyMap()
    }
}
// -------------------- Video Splash Composable --------------------
/**
 * Plays a fullscreen MP4 from res/raw and calls [onFinished] when playback ends.
 * Uses Media3 (ExoPlayer) inside AndroidView and cleans up the player automatically.
 *
 * Requirements:
 *  - Put your splash MP4 at app/src/main/res/raw/splash_video.mp4
 *  - Add media3 / exoplayer dependencies to your module Gradle
 */
@Composable
fun VideoSplashScreen(
    @RawRes videoResId: Int = R.raw.splash_video,
    onFinished: () -> Unit
) {
    val context = LocalContext.current

    // remember player to avoid recreation on recomposition
    val exoPlayer = remember {
        ExoPlayer.Builder(context).build().apply {
            val uri = Uri.parse("android.resource://${context.packageName}/$videoResId")
            setMediaItem(MediaItem.fromUri(uri))
            prepare()
            playWhenReady = true
            // Optionally mute: volume = 0f
            // Optionally loop: repeatMode = Player.REPEAT_MODE_ONE
        }
    }

    var ended by remember { mutableStateOf(false) }

    DisposableEffect(exoPlayer) {
        val listener = object : Player.Listener {
            override fun onPlaybackStateChanged(state: Int) {
                if (state == Player.STATE_ENDED) {
                    ended = true
                }
            }
        }
        exoPlayer.addListener(listener)

        onDispose {
            exoPlayer.removeListener(listener)
            exoPlayer.release()
        }
    }

    LaunchedEffect(ended) {
        if (ended) {
            // tiny delay to allow last frame to render / a short fade if you later add one
            kotlinx.coroutines.delay(180L)
            onFinished()
        }
    }

    AndroidView(
        factory = { ctx ->
            PlayerView(ctx).apply {
                player = exoPlayer
                useController = false
                layoutParams = FrameLayout.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.MATCH_PARENT
                )
            }
        },
        modifier = Modifier.fillMaxSize()
    )
}

// -------------------- MainActivity and UI --------------------
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        // Use system splash screen for fast native launch (Android 12+)
        installSplashScreen()

        super.onCreate(savedInstanceState)
        setContent {
            ObstrueTheme {
                // Show the video splash first, then render the original NavHost
                var showSplash by remember { mutableStateOf(true) }

                if (showSplash) {
                    VideoSplashScreen(videoResId = R.raw.splash_video) {
                        showSplash = false
                    }
                } else {
                    val navController = rememberNavController()
                    NavHost(
                        navController = navController,
                        startDestination = "main"
                    ) {
                        composable("main") { ObstrueMainScreen(navController) }
                        composable("msg_voices") { MsgVoicesScreen(navController) }
                        composable("todo") { ObstrueToDoScreen(navController) }
                        composable("statistics") { ObstrueStatistics(navController) }
                        composable("settings") { ObstrueSettings(navController) }

                        composable("schedulegui/{pkg}") { backStackEntry ->
                            val pkgArg = backStackEntry.arguments?.getString("pkg")?.let { if (it.isNotBlank()) Uri.decode(it) else null }
                            ScheduleGuiScreen(navController = navController, incomingPkg = pkgArg)
                        }
                        composable("schedulegui") {
                            ScheduleGuiScreen(navController = navController, incomingPkg = null)
                        }
                    }
                }
            }
        }
    }
}

/**
 * Blocking Activity shown when a blocked app is opened and its time is exceeded.
 * Uses window flags to try to show above locked screen where allowed.
 */
class BlockedActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // These flags help the activity appear on top / when device is locked where policy allows.
        window.addFlags(
            WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON or
                    WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED or
                    WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON
        )

        // Prevent finish when touching outside
        setFinishOnTouchOutside(false)

        setContent {
            Surface(modifier = Modifier.fillMaxSize(), color = Color(0xCC0B0710)) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(24.dp),
                    verticalArrangement = Arrangement.Center,
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(text = "Test successful", color = Color.White, fontSize = 24.sp, fontWeight = FontWeight.Bold)
                    Spacer(modifier = Modifier.height(20.dp))
                    Button(onClick = { finish() }) {
                        Text("Exit")
                    }
                }
            }
        }
    }

    override fun finish() {
        super.finish()
        overridePendingTransition(0, 0)
    }
}

@Composable
fun ObstrueMainScreen(navController: NavHostController) {
    val context = LocalContext.current

    val configuration = LocalConfiguration.current
    val bottomBarHeight = (configuration.screenHeightDp * 0.11f).coerceIn(72f, 120f).dp

    val blockedApps = remember { mutableStateListOf<AppEntry>() }
    val installedApps = remember { mutableStateListOf<AppEntry>() }

    var showAddDialog by remember { mutableStateOf(false) }
    var showNeedPermissionPrompt by remember { mutableStateOf(false) }

    var showScheduleDialog by remember { mutableStateOf(false) }
    var scheduleTargetPkg by remember { mutableStateOf<String?>(null) }
    var scheduleTargetLabel by remember { mutableStateOf<String?>(null) }
    var scheduleSelectedMinutes by remember { mutableStateOf(0) }

    val appTimeLimits = remember { mutableStateMapOf<String, Int>() }
    val appUsage = remember { mutableStateMapOf<String, Int>() } // minutes per package

    val coroutineScope = rememberCoroutineScope()
    var monitorJob by remember { mutableStateOf<Job?>(null) }

    val prefs = context.getSharedPreferences("obstrue_prefs", android.content.Context.MODE_PRIVATE)
    var isLocked by remember { mutableStateOf(prefs.getBoolean("is_locked", false)) }
    var pressed by remember { mutableStateOf(false) }

    // helper: open usage access settings
    fun openUsageAccessSettings() {
        try {
            val intent = Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS)
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            context.startActivity(intent)
        } catch (t: Throwable) {
            val fallback = Intent(Settings.ACTION_SETTINGS)
            fallback.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            context.startActivity(fallback)
        }
    }

    fun openManageAllAppsSettings() {
        try {
            val intent = Intent(Settings.ACTION_MANAGE_ALL_APPLICATIONS_SETTINGS)
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            context.startActivity(intent)
        } catch (t: Throwable) {
            try {
                val intent2 = Intent(Settings.ACTION_APPLICATION_SETTINGS)
                intent2.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                context.startActivity(intent2)
            } catch (_: Throwable) {
            }
        }
    }

    // Refresh usage for blocked apps using precise events-based helper.
    suspend fun refreshUsageForBlockedApps() {
        try {
            val pkgs = blockedApps.map { it.packageName }
            if (pkgs.isEmpty()) return
            val usageMap = getUsageMinutesForPackages(context, pkgs)
            // persist + update UI-state
            for ((pkg, minutes) in usageMap) {
                saveAppUsageToPrefs(context, pkg, minutes)
            }
            kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.Main) {
                usageMap.forEach { (pkg, minutes) -> appUsage[pkg] = minutes }
            }
        } catch (e: Exception) {
            // keep previous data on error
        }
    }

    // Monitoring job: polls usage events and shows BlockedActivity if needed
    fun startMonitoringBlockedApps() {
        monitorJob?.cancel()
        monitorJob = coroutineScope.launch {
            val usageMgr = context.getSystemService(Context.USAGE_STATS_SERVICE) as? UsageStatsManager
            if (usageMgr == null) return@launch

            while (isActive) {
                try {
                    // Reload time limits each loop so changes are picked up without restarting monitor
                    val freshLimits = try { loadAppTimeLimitsFromPrefs(context) } catch (_: Exception) { emptyMap() }

                    // scan the last few seconds of events for foreground
                    val end = System.currentTimeMillis()
                    val begin = end - 3000L
                    val events = usageMgr.queryEvents(begin, end)
                    val ev = UsageEvents.Event()
                    var foregroundPkg: String? = null
                    while (events.hasNextEvent()) {
                        events.getNextEvent(ev)
                        if (ev.eventType == UsageEvents.Event.MOVE_TO_FOREGROUND) {
                            foregroundPkg = ev.packageName
                        }
                    }

                    if (!foregroundPkg.isNullOrBlank()) {
                        val pkg = foregroundPkg
                        val limit = freshLimits[pkg] ?: 0
                        val isBlockedPkg = blockedApps.any { it.packageName == pkg }
                        if (limit > 0 && isBlockedPkg) {
                            try {
                                // get up-to-date minutes for this pkg (today)
                                val usageMap = getUsageMinutesForPackages(context, listOf(pkg))
                                val usedMin = usageMap[pkg] ?: 0

                                saveAppUsageToPrefs(context, pkg, usedMin)
                                kotlinx.coroutines.withContext(kotlin.coroutines.Dispatchers.Main) {
                                    appUsage[pkg] = usedMin
                                }

                                if (usedMin >= limit) {
                                    // Time's up -> launch BlockedActivity
                                    try {
                                        val intent = Intent(context, BlockedActivity::class.java).apply {
                                            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_NO_ANIMATION or Intent.FLAG_ACTIVITY_MULTIPLE_TASK)
                                            putExtra("blocked_pkg", pkg)
                                        }
                                        context.startActivity(intent)
                                    } catch (t: Throwable) {
                                        // background start may be restricted on some devices/OS versions
                                    }

                                    // small cooldown to avoid spamming launches
                                    kotlinx.coroutines.delay(1500L)
                                }
                            } catch (_: Exception) {
                                // ignore per-package errors
                            }
                        }
                    }
                } catch (_: Exception) {
                    // protect loop
                }

                kotlinx.coroutines.delay(1000L)
            }
        }
    }

    fun stopMonitoringBlockedApps() {
        monitorJob?.cancel()
        monitorJob = null
    }

    // Initial load: blocked apps, time limits, usage
    LaunchedEffect(Unit) {
        val pm = context.packageManager
        val visibleCount = try { pm.getInstalledApplications(PackageManager.GET_META_DATA).size } catch (_: Throwable) { 0 }
        if (visibleCount < 8) {
            showNeedPermissionPrompt = true
        } else {
            kotlinx.coroutines.withContext(kotlin.coroutines.Dispatchers.IO) {
                val loaded = loadBlockedAppsFromPrefs(context)
                val times = loadAppTimeLimitsFromPrefs(context)
                val usages = loadAppUsageFromPrefs(context)
                kotlinx.coroutines.withContext(kotlin.coroutines.Dispatchers.Main) {
                    if (loaded.isNotEmpty()) {
                        blockedApps.clear(); blockedApps.addAll(loaded)
                    }
                    if (times.isNotEmpty()) {
                        appTimeLimits.clear(); appTimeLimits.putAll(times)
                    }
                    if (usages.isNotEmpty()) {
                        appUsage.clear(); appUsage.putAll(usages)
                    }

                    // if already locked, start monitoring
                    if (isLocked) startMonitoringBlockedApps()
                }
            }
        }
    }

    // watch lock changes
    LaunchedEffect(isLocked) {
        prefs.edit().putBoolean("is_locked", isLocked).apply()
        if (isLocked) {
            startMonitoringBlockedApps()
        } else {
            stopMonitoringBlockedApps()
        }
    }

    LaunchedEffect(blockedApps.size) {
        // refresh usage periodically while UI active
        while (isActive) {
            try {
                refreshUsageForBlockedApps()
            } catch (_: Exception) {}
            kotlinx.coroutines.delay(15_000L)
        }
    }

    fun onAddAppClicked() {
        val pm = context.packageManager
        val visibleCount = try { pm.getInstalledApplications(PackageManager.GET_META_DATA).size } catch (t: Throwable) { 0 }
        if (visibleCount < 8) {
            showNeedPermissionPrompt = true
        } else {
            showAddDialog = true
        }
    }

    LaunchedEffect(showAddDialog) {
        if (showAddDialog && installedApps.isEmpty()) {
            val list = kotlinx.coroutines.withContext(kotlin.coroutines.Dispatchers.IO) {
                val pm = context.packageManager
                pm.getInstalledApplications(PackageManager.GET_META_DATA)
                    .mapNotNull { appInfo ->
                        try {
                            val pkg = appInfo.packageName
                            if (pkg == context.packageName) return@mapNotNull null
                            val installer = try {
                                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) pm.getInstallSourceInfo(pkg).initiatingPackageName
                                else pm.getInstallerPackageName(pkg)
                            } catch (_: Exception) { null }
                            val label = pm.getApplicationLabel(appInfo).toString()
                            val launchIntent = pm.getLaunchIntentForPackage(pkg)
                            val isSystem = (appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0
                            val isUpdatedSystem = (appInfo.flags and ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0
                            if ((isSystem && !isUpdatedSystem) || launchIntent == null) return@mapNotNull null
                            val installerOk = installer == "com.android.vending" || installer == "com.google.android.feedback"
                            if (!installerOk) return@mapNotNull null
                            val drawable = pm.getApplicationIcon(pkg)
                            val bmp = drawable.toBitmap()
                            val imgBitmap = bmp.asImageBitmap()
                            AppEntry(pkg, label, imgBitmap, installer, isSystem, isUpdatedSystem)
                        } catch (e: Exception) {
                            null
                        }
                    }
                    .distinctBy { it.packageName }
                    .sortedBy { it.label.lowercase() }
            }
            installedApps.addAll(list)
            try { saveInstalledAppsToPrefs(context, list) } catch (_: Exception) {}
            if (list.size < 6) showNeedPermissionPrompt = true
        }
    }

    // load persisted lists again (keeps UI consistent)
    LaunchedEffect(Unit) {
        val loaded = kotlinx.coroutines.withContext(kotlin.coroutines.Dispatchers.IO) { loadBlockedAppsFromPrefs(context) }
        if (loaded.isNotEmpty()) { blockedApps.clear(); blockedApps.addAll(loaded) }
        val times = kotlinx.coroutines.withContext(kotlin.coroutines.Dispatchers.IO) { loadAppTimeLimitsFromPrefs(context) }
        if (times.isNotEmpty()) { appTimeLimits.clear(); appTimeLimits.putAll(times) }
        val usages = kotlinx.coroutines.withContext(kotlin.coroutines.Dispatchers.IO) { loadAppUsageFromPrefs(context) }
        if (usages.isNotEmpty()) { appUsage.clear(); appUsage.putAll(usages) }
    }

    // ---------------- UI (unchanged core layout) ----------------
    Box(modifier = Modifier
        .fillMaxSize()
        .background(Color(0xFF0B0710))
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(rememberScrollState())
                .padding(horizontal = 18.dp, vertical = 18.dp)
                .padding(bottom = 140.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Spacer(modifier = Modifier.height(14.dp))
            Text(
                text = "Obstrue",
                color = Color(0xFFEFE7F6),
                fontSize = 36.sp,
                fontWeight = FontWeight.ExtraBold
            )

            Spacer(modifier = Modifier.height(6.dp))

            Text(
                text = "Block apps and master your focus",
                color = Color(0xFFBDB0C8),
                fontSize = 16.sp,
                fontWeight = FontWeight.Medium
            )
            Spacer(modifier = Modifier.height(18.dp))

            // Make big lock button use no-ripple clickable so press feels instant (no fade/ripple)
            val lockInteraction = remember { MutableInteractionSource() }
            Box(
                modifier = Modifier
                    .size(220.dp)
                    .scale(if (pressed) 0.92f else 1f)
                    .clickable(interactionSource = lockInteraction, indication = null) {
                        isLocked = !isLocked
                        prefs.edit().putBoolean("is_locked", isLocked).apply()
                        pressed = true
                    },
                contentAlignment = Alignment.Center
            ) {
                LaunchedEffect(pressed) {
                    if (pressed) {
                        kotlinx.coroutines.delay(120)
                        pressed = false
                    }
                }
                Image(
                    painter = painterResource(id = if (isLocked) R.drawable.lock else R.drawable.unlock),
                    contentDescription = if (isLocked) "Locked" else "Unlocked",
                    modifier = Modifier.fillMaxSize(),
                    contentScale = ContentScale.Fit
                )
            }

            Spacer(modifier = Modifier.height(10.dp))
            // Status label under the large lock icon (no bold)
            Surface(
                shape = RoundedCornerShape(20.dp),
                color = Color(0xFF1E1620),
                modifier = Modifier.wrapContentWidth()
            ) {
                Text(
                    text = if (isLocked) "Locked" else "Unlocked",
                    color = Color(0xFFEDE9F2),
                    fontSize = 16.sp,
                    fontWeight = FontWeight.Normal,
                    modifier = Modifier.padding(horizontal = 14.dp, vertical = 8.dp)
                )
            }

            Spacer(modifier = Modifier.height(18.dp))
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(12.dp, Alignment.CenterHorizontally)) {
                Button(onClick = { onAddAppClicked() }, modifier = Modifier.weight(1f).height(44.dp), shape = RoundedCornerShape(10.dp), colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF2A1E2B))) {
                    Text(text = "+ App", color = Color(0xFFF0EAF6), fontSize = 15.sp)
                }

                Button(onClick = {
                    if (blockedApps.isNotEmpty()) {
                        val firstPkg = blockedApps[0].packageName
                        navController.navigate("schedulegui/${Uri.encode(firstPkg)}", navOptions {
                            anim { enter = 0; exit = 0; popEnter = 0; popExit = 0 }; launchSingleTop = true
                        })
                    } else {
                        navController.navigate("schedulegui", navOptions {
                            anim { enter = 0; exit = 0; popEnter = 0; popExit = 0 }; launchSingleTop = true
                        })
                    }
                }, modifier = Modifier.weight(1f).height(44.dp), shape = RoundedCornerShape(10.dp), colors = ButtonDefaults.buttonColors(containerColor = Color(0xFF2A1E2B))) {
                    Text(text = "+ Schedule", color = Color(0xFFF0EAF6), fontSize = 15.sp)
                }
            }

            Spacer(modifier = Modifier.height(18.dp))

            // ------------------ Random tip selection ------------------
            val tips = listOf(
                "Use the Msg & Voices section to display a custom message and sound when you waste time",
                "Navigate to To-Do section to create a to do list",
                "Go on the Statistics Section to see App Statistics"
            )
            val tipText = remember { tips.random() }

            Text(text = "Tip: $tipText", color = Color(0xFFB9AFC6), fontSize = 12.sp, modifier = Modifier.padding(horizontal = 6.dp))
            Spacer(modifier = Modifier.height(18.dp))

            Surface(shape = RoundedCornerShape(12.dp), color = Color(0xFF241827), modifier = Modifier.fillMaxWidth()) {
                Column(modifier = Modifier.padding(14.dp)) {
                    Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.fillMaxWidth()) {
                        Text(text = "Blocked apps", color = Color(0xFFDCD0E7), fontSize = 16.sp, fontWeight = FontWeight.SemiBold)
                        Spacer(modifier = Modifier.weight(1f))
                        Text(text = "${blockedApps.size} items", color = Color(0xFFBFAFC6), fontSize = 12.sp)
                    }

                    Spacer(modifier = Modifier.height(12.dp))

                    if (blockedApps.isEmpty()) {
                        Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                            Text(text = "No apps blocked yet", color = Color(0xFF8F8F8F), fontSize = 14.sp)
                        }
                        Spacer(modifier = Modifier.height(8.dp))
                    } else {
                        LazyColumn(modifier = Modifier.fillMaxWidth().heightIn(min = 0.dp, max = 240.dp)) {
                            items(blockedApps) { app ->
                                // make the app row clickable without ripple/fade
                                val rowInteraction = remember { MutableInteractionSource() }
                                Row(modifier = Modifier
                                    .fillMaxWidth()
                                    .clickable(interactionSource = rowInteraction, indication = null) {
                                        if (isLocked) {
                                            Toast.makeText(context, "${app.label} is blocked while locked", Toast.LENGTH_SHORT).show()
                                        } else {
                                            val launch = context.packageManager.getLaunchIntentForPackage(app.packageName)
                                            if (launch != null) {
                                                launch.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                                                context.startActivity(launch)
                                            } else {
                                                Toast.makeText(context, "Can't open ${app.label}", Toast.LENGTH_SHORT).show()
                                            }
                                        }
                                    }
                                    .padding(vertical = 6.dp).padding(horizontal = 4.dp),
                                    verticalAlignment = Alignment.CenterVertically) {
                                    Image(bitmap = app.iconBitmap, contentDescription = app.label, modifier = Modifier.size(44.dp))
                                    Spacer(modifier = Modifier.width(12.dp))
                                    Column(modifier = Modifier.weight(1f)) {
                                        Text(text = app.label, color = Color(0xFFEFE7F7), fontSize = 15.sp)
                                        val tm = appTimeLimits[app.packageName] ?: 0
                                        val used = appUsage[app.packageName] ?: 0
                                        if (tm > 0 || used > 0) {
                                            val limitText = if (tm > 0) "Limit: ${formatMinutesReadable(tm)}" else "Limit: —"
                                            val usedText = "Used: ${used} min"
                                            Text(text = "$limitText | $usedText", color = Color(0xFFBFAFC6), fontSize = 12.sp)
                                        }
                                    }

                                    IconButton(onClick = {
                                        scheduleTargetPkg = app.packageName
                                        scheduleTargetLabel = app.label
                                        scheduleSelectedMinutes = appTimeLimits[app.packageName] ?: 0
                                        showScheduleDialog = true
                                    }, modifier = Modifier.size(44.dp)) {
                                        Image(painter = painterResource(id = R.drawable.clock), contentDescription = "Set schedule", modifier = Modifier.fillMaxSize())
                                    }

                                    Spacer(modifier = Modifier.width(6.dp))

                                    IconButton(onClick = {
                                        blockedApps.remove(app)
                                        removeAppTimeLimitFromPrefs(context, app.packageName)
                                        appTimeLimits.remove(app.packageName)
                                        removeAppUsageFromPrefs(context, app.packageName)
                                        appUsage.remove(app.packageName)
                                        saveBlockedAppsToPrefs(context, blockedApps)
                                    }, modifier = Modifier.size(36.dp)) {
                                        Icon(imageVector = Icons.Default.Close, contentDescription = "Remove", tint = Color(0xFFBFAFC6))
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Spacer(modifier = Modifier.height(28.dp))
            Spacer(modifier = Modifier.height(48.dp))
        }

        // ----------------- persistent rectangle behind bottom icons -----------------
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .align(Alignment.BottomCenter)
                .height(bottomBarHeight + 10.dp)
                .navigationBarsPadding()
                .background(Color(0xFF0B0710))
        )

        // Bottom icons Row (no background)
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .align(Alignment.BottomCenter)
                .navigationBarsPadding()
                .padding(bottom = 12.dp, start = 8.dp, end = 8.dp),
            horizontalArrangement = Arrangement.Start,
            verticalAlignment = Alignment.CenterVertically
        ) {
            BottomNavItemWithLabelMain(resId = R.drawable.house, label = "Home", modifier = Modifier.weight(1f)) {
                navController.navigate("main", navOptions { launchSingleTop = true })
            }
            BottomNavItemWithLabelMain(resId = R.drawable.unselectedmsgbutton, label = "Msg & Voices", modifier = Modifier.weight(1f)) {
                navController.navigate("msg_voices", navOptions { launchSingleTop = true })
            }
            BottomNavItemWithLabelMain(resId = R.drawable.statsoutline, label = "Statistics", modifier = Modifier.weight(1f)) {
                navController.navigate("statistics", navOptions { launchSingleTop = true })
            }
            BottomNavItemWithLabelMain(resId = R.drawable.checkboxem, label = "To-do", modifier = Modifier.weight(1f)) {
                navController.navigate("todo", navOptions { launchSingleTop = true; restoreState = true; popUpTo(navController.graph.startDestinationId) { saveState = true } })
            }
        }
    }

    // permission dialog
    if (showNeedPermissionPrompt) {
        AlertDialog(
            onDismissRequest = { showNeedPermissionPrompt = false },
            title = { Text("Allow access to apps") },
            text = {
                Text("To list Play Store apps and show usage times, Obstrue needs Usage Access. Please grant Usage Access and open Apps settings if required.")
            },
            confirmButton = {
                TextButton(onClick = {
                    showNeedPermissionPrompt = false
                    openUsageAccessSettings()
                }) { Text("Open Usage Access") }
            },
            dismissButton = {
                Row {
                    TextButton(onClick = { showNeedPermissionPrompt = false; showAddDialog = true }) { Text("Continue anyway") }
                    TextButton(onClick = { showNeedPermissionPrompt = false; openManageAllAppsSettings() }) { Text("Open Apps settings") }
                }
            }
        )
    }

    // schedule dialog...
    if (showScheduleDialog) {
        AlertDialog(
            onDismissRequest = { showScheduleDialog = false; scheduleTargetPkg = null; scheduleTargetLabel = null },
            title = { Text(scheduleTargetLabel ?: "Set time limit") },
            text = {
                Column {
                    Text(text = "Set a daily time limit for this app. Use the slider or type hours/minutes.", color = Color(0xFFD7CBE0), fontSize = 13.sp)
                    Spacer(modifier = Modifier.height(12.dp))
                    val selectedFormatted = formatMinutesReadable(scheduleSelectedMinutes)
                    Text(text = "Selected: $selectedFormatted", color = Color(0xFFBFAFC6))
                    Spacer(modifier = Modifier.height(8.dp))
                    Slider(value = scheduleSelectedMinutes.toFloat(), onValueChange = { v -> scheduleSelectedMinutes = v.toInt() }, valueRange = 0f..(24 * 60).toFloat(), modifier = Modifier.fillMaxWidth())
                    Spacer(modifier = Modifier.height(8.dp))
                    Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                        val hours = scheduleSelectedMinutes / 60
                        val minutes = scheduleSelectedMinutes % 60
                        OutlinedTextField(value = hours.toString(), onValueChange = { str ->
                            val filtered = str.filter { it.isDigit() }
                            val h = filtered.takeIf { it.isNotEmpty() }?.toIntOrNull() ?: 0
                            val clampedH = h.coerceIn(0, 24)
                            val currentM = scheduleSelectedMinutes % 60
                            val newMinutes = if (clampedH == 24) 0 else currentM
                            scheduleSelectedMinutes = clampedH * 60 + newMinutes
                        }, label = { Text("Hours") }, singleLine = true, modifier = Modifier.width(120.dp))
                        OutlinedTextField(value = minutes.toString(), onValueChange = { str ->
                            val filtered = str.filter { it.isDigit() }
                            val m = filtered.takeIf { it.isNotEmpty() }?.toIntOrNull() ?: 0
                            val currentH = scheduleSelectedMinutes / 60
                            val clampedM = m.coerceIn(0, 59)
                            val newMinutes = if (currentH == 24) 0 else clampedM
                            scheduleSelectedMinutes = currentH * 60 + newMinutes
                        }, label = { Text("Minutes") }, singleLine = true, modifier = Modifier.width(120.dp))
                        Spacer(modifier = Modifier.weight(1f))
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = {
                    val pkg = scheduleTargetPkg
                    if (!pkg.isNullOrBlank()) {
                        saveAppTimeLimitToPrefs(context, pkg, scheduleSelectedMinutes)
                        appTimeLimits[pkg] = scheduleSelectedMinutes
                        coroutineScope.launch {
                            kotlinx.coroutines.withContext(kotlin.coroutines.Dispatchers.IO) {
                                try {
                                    val usageMgr = context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager
                                    val cal = Calendar.getInstance()
                                    cal.set(Calendar.HOUR_OF_DAY, 0)
                                    cal.set(Calendar.MINUTE, 0)
                                    cal.set(Calendar.SECOND, 0)
                                    cal.set(Calendar.MILLISECOND, 0)
                                    val begin = cal.timeInMillis
                                    val end = System.currentTimeMillis()
                                    val aggregated = usageMgr.queryAndAggregateUsageStats(begin, end)
                                    val us = aggregated[pkg]
                                    val usedMs = us?.totalTimeInForeground ?: 0L
                                    val usedMin = (usedMs / 60000L).toInt()
                                    saveAppUsageToPrefs(context, pkg, usedMin)
                                    kotlinx.coroutines.withContext(kotlin.coroutines.Dispatchers.Main) { appUsage[pkg] = usedMin }
                                } catch (_: Exception) {}
                            }
                        }
                        Toast.makeText(context, "Saved: ${formatMinutesReadable(scheduleSelectedMinutes)} for ${scheduleTargetLabel}", Toast.LENGTH_SHORT).show()
                    }
                    showScheduleDialog = false
                    scheduleTargetPkg = null
                    scheduleTargetLabel = null
                }) { Text("Done") }
            },
            dismissButton = {
                TextButton(onClick = { showScheduleDialog = false; scheduleTargetPkg = null; scheduleTargetLabel = null }) { Text("Cancel") }
            }
        )
    }

    if (showAddDialog) {
        AlertDialog(onDismissRequest = { showAddDialog = false }, title = { Text("Select apps to block") }, text = {
            Column {
                Text(text = "Tap an app to add it to blocked list. Use Done when finished.", color = Color(0xFFD7CBE0), fontSize = 13.sp)
                Spacer(modifier = Modifier.height(12.dp))
                Surface(modifier = Modifier.fillMaxWidth().heightIn(max = 420.dp), color = Color(0xFF0F0C0E)) {
                    if (installedApps.isEmpty()) {
                        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                            Text("Loading apps...", color = Color(0xFF8F8F8F))
                        }
                    } else {
                        LazyColumn(modifier = Modifier.padding(8.dp)) {
                            items(installedApps) { app ->
                                // installed-apps rows also use no-ripple clickable for instant feel
                                val addRowInteraction = remember { MutableInteractionSource() }
                                Row(modifier = Modifier.fillMaxWidth()
                                    .clickable(interactionSource = addRowInteraction, indication = null) {
                                        if (blockedApps.none { it.packageName == app.packageName }) {
                                            blockedApps.add(app)
                                            saveBlockedAppsToPrefs(context, blockedApps)
                                            Toast.makeText(context, "${app.label} added to blocked list", Toast.LENGTH_SHORT).show()
                                        }
                                    }
                                    .padding(vertical = 8.dp), verticalAlignment = Alignment.CenterVertically) {
                                    Image(bitmap = app.iconBitmap, contentDescription = app.label, modifier = Modifier.size(40.dp))
                                    Spacer(modifier = Modifier.width(12.dp))
                                    Column(modifier = Modifier.weight(1f)) {
                                        Text(text = app.label, color = Color.White, fontSize = 14.sp)
                                        Text(text = app.installerPackage ?: "", color = Color(0xFF8F8F8F), fontSize = 11.sp, maxLines = 1)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }, confirmButton = { TextButton(onClick = { showAddDialog = false }) { Text("Done") } }, dismissButton = { TextButton(onClick = { showAddDialog = false }) { Text("Cancel") } })
    }
}

@Composable
private fun BottomNavItemWithLabelMain(resId: Int, label: String, modifier: Modifier = Modifier, onClick: () -> Unit) {
    val iconSize = 32.dp
    // Use a no-ripple/no-indication clickable here so tapping the bottom nav feels instant with no fade/ripple
    val noRipple = remember { MutableInteractionSource() }
    Column(horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center, modifier = modifier.clickable(interactionSource = noRipple, indication = null, onClick = onClick).padding(vertical = 6.dp)) {
        Image(painter = painterResource(id = resId), contentDescription = label, modifier = Modifier.size(iconSize), contentScale = ContentScale.Fit)
        Spacer(modifier = Modifier.height(6.dp))
        Text(text = label, color = Color(0xFFCFD7E6), fontSize = 11.sp, maxLines = 1)
    }
}

@Composable
fun ObstrueSettings(navController: NavHostController) {
    Box(modifier = Modifier.fillMaxSize().background(Color(0xFF0B0710)), contentAlignment = Alignment.Center) {
        Text("Settings (placeholder)", color = Color.White)
    }
}
